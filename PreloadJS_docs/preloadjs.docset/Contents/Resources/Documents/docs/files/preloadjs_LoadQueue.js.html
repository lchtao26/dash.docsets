<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css"/>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css"/>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles"/>
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico"/>
    <script src="../assets/js/yui-source.js"></script>
	<title>PreloadJS v1.0.0 API Documentation : preloadjs/LoadQueue.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><a href="http://www.createjs.com/preloadjs"><img src="../assets/docs-icon-PreloadJS.png" title="PreloadJS"/></a></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs"/>
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AbstractLoader.html">AbstractLoader</a></li>
            
                <li><a href="../classes/AbstractMediaLoader.html">AbstractMediaLoader</a></li>
            
                <li><a href="../classes/AbstractRequest.html">AbstractRequest</a></li>
            
                <li><a href="../classes/BinaryLoader.html">BinaryLoader</a></li>
            
                <li><a href="../classes/CSSLoader.html">CSSLoader</a></li>
            
                <li><a href="../classes/DataUtils.html">DataUtils</a></li>
            
                <li><a href="../classes/DomUtils.html">DomUtils</a></li>
            
                <li><a href="../classes/ErrorEvent.html">ErrorEvent</a></li>
            
                <li><a href="../classes/Event.html">Event</a></li>
            
                <li><a href="../classes/EventDispatcher.html">EventDispatcher</a></li>
            
                <li><a href="../classes/FontLoader.html">FontLoader</a></li>
            
                <li><a href="../classes/ImageLoader.html">ImageLoader</a></li>
            
                <li><a href="../classes/JavaScriptLoader.html">JavaScriptLoader</a></li>
            
                <li><a href="../classes/JSONLoader.html">JSONLoader</a></li>
            
                <li><a href="../classes/JSONPLoader.html">JSONPLoader</a></li>
            
                <li><a href="../classes/LoadItem.html">LoadItem</a></li>
            
                <li><a href="../classes/LoadQueue.html">LoadQueue</a></li>
            
                <li><a href="../classes/ManifestLoader.html">ManifestLoader</a></li>
            
                <li><a href="../classes/MediaTagRequest.html">MediaTagRequest</a></li>
            
                <li><a href="../classes/PreloadJS.html">PreloadJS</a></li>
            
                <li><a href="../classes/ProgressEvent.html">ProgressEvent</a></li>
            
                <li><a href="../classes/RequestUtils.html">RequestUtils</a></li>
            
                <li><a href="../classes/SamplePlugin.html">SamplePlugin</a></li>
            
                <li><a href="../classes/SoundLoader.html">SoundLoader</a></li>
            
                <li><a href="../classes/SpriteSheetLoader.html">SpriteSheetLoader</a></li>
            
                <li><a href="../classes/SVGLoader.html">SVGLoader</a></li>
            
                <li><a href="../classes/TagRequest.html">TagRequest</a></li>
            
                <li><a href="../classes/TextLoader.html">TextLoader</a></li>
            
                <li><a href="../classes/URLUtils.html">URLUtils</a></li>
            
                <li><a href="../classes/Utility Methods.html">Utility Methods</a></li>
            
                <li><a href="../classes/VideoLoader.html">VideoLoader</a></li>
            
                <li><a href="../classes/XHRRequest.html">XHRRequest</a></li>
            
                <li><a href="../classes/XMLLoader.html">XMLLoader</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/CreateJS.html">CreateJS</a></li>
            
                <li><a href="../modules/PreloadJS.html">PreloadJS</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked=""/>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected"/>
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private"/>
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated"/>
            Deprecated
        </label>

    </div>
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content source-content">
                        <script>
	var name = preloadjs/LoadQueue.js      
</script>
<a class="dashingAutolink" name="autolink-592"></a><a class="dashAnchor" name="//apple_ref/cpp/File/File%3ALoadQueue.js"></a><a class="dashingAutolink" name="autolink-593"></a><a class="dashAnchor" name="//apple_ref/cpp/Class/File%3ALoadQueue.js"></a><h1 class="file-heading">File:LoadQueue.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">/*
 * LoadQueue
 * Visit http://createjs.com/ for documentation, updates and examples.
 *
 *
 * Copyright (c) 2012 gskinner.com, inc.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the &#34;Software&#34;), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * PreloadJS provides a consistent way to preload content for use in HTML applications. Preloading can be done using
 * HTML tags, as well as XHR.
 *
 * By default, PreloadJS will try and load content using XHR, since it provides better support for progress and
 * completion events, &lt;b&gt;however due to cross-domain issues, it may still be preferable to use tag-based loading
 * instead&lt;/b&gt;. Note that some content requires XHR to work (plain text, web audio), and some requires tags (HTML audio).
 * Note this is handled automatically where possible.
 *
 * PreloadJS currently supports all modern browsers, and we have done our best to include support for most older
 * browsers. If you find an issue with any specific OS/browser combination, please visit http://community.createjs.com/
 * and report it.
 *
 * &lt;h4&gt;Getting Started&lt;/h4&gt;
 * To get started, check out the {{#crossLink &#34;LoadQueue&#34;}}{{/crossLink}} class, which includes a quick overview of how
 * to load files and process results.
 *
 * &lt;h4&gt;Example&lt;/h4&gt;
 *
 *      var queue = new createjs.LoadQueue();
 *      queue.installPlugin(createjs.Sound);
 *      queue.on(&#34;complete&#34;, handleComplete, this);
 *      queue.loadFile({id:&#34;sound&#34;, src:&#34;http://path/to/sound.mp3&#34;});
 *      queue.loadManifest([
 *          {id: &#34;myImage&#34;, src:&#34;path/to/myImage.jpg&#34;}
 *      ]);
 *      function handleComplete() {
 *          createjs.Sound.play(&#34;sound&#34;);
 *          var image = queue.getResult(&#34;myImage&#34;);
 *          document.body.appendChild(image);
 *      }
 *
 * &lt;b&gt;Important note on plugins:&lt;/b&gt; Plugins must be installed &lt;i&gt;before&lt;/i&gt; items are added to the queue, otherwise
 * they will not be processed, even if the load has not actually kicked off yet. Plugin functionality is handled when
 * the items are added to the LoadQueue.
 *
 * &lt;h4&gt;Browser Support&lt;/h4&gt;
 * PreloadJS is partially supported in all browsers, and fully supported in all modern browsers. Known exceptions:
 * &lt;ul&gt;&lt;li&gt;XHR loading of any content will not work in many older browsers (See a matrix here: &lt;a href=&#34;http://caniuse.com/xhr2&#34; target=&#34;_blank&#34;&gt;http://caniuse.com/xhr2&lt;/a&gt;).
 *      In many cases, you can fall back on tag loading (images, audio, CSS, scripts, and SVG). Text and
 *      WebAudio will only work with XHR.&lt;/li&gt;
 *      &lt;li&gt;Some formats have poor support for complete events in IE 6, 7, and 8 (SVG, tag loading of scripts, XML/JSON)&lt;/li&gt;
 *      &lt;li&gt;Opera has poor support for SVG loading with XHR&lt;/li&gt;
 *      &lt;li&gt;CSS loading in Android and Safari will not work with tags (currently, a workaround is in progress)&lt;/li&gt;
 *      &lt;li&gt;Local loading is not permitted with XHR, which is required by some file formats. When testing local content
 *      use either a local server, or enable tag loading, which is supported for most formats. See {{#crossLink &#34;LoadQueue/setPreferXHR&#34;}}{{/crossLink}}
 *      for more information.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h4&gt;Cross-domain Loading&lt;/h4&gt;
 * Most content types can be loaded cross-domain, as long as the server supports CORS. PreloadJS also has internal
 * support for images served from a CORS-enabled server, via the `crossOrigin` argument on the {{#crossLink &#34;LoadQueue&#34;}}{{/crossLink}}
 * constructor. If set to a string value (such as &#34;Anonymous&#34;), the &#34;crossOrigin&#34; property of images generated by
 * PreloadJS is set to that value. Please note that setting a `crossOrigin` value on an image that is served from a
 * server without CORS will cause other errors. For more info on CORS, visit https://en.wikipedia.org/wiki/Cross-origin_resource_sharing.
 *
 * @module PreloadJS
 * @main PreloadJS
 */

// namespace:
this.createjs = this.createjs || {};

/*
 TODO: WINDOWS ISSUES
 * No error for HTML audio in IE 678
 * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR
 * No script complete handler in IE 67 TAGS (XHR is fine)
 * No XML/JSON in IE6 TAGS
 * Need to hide loading SVG in Opera TAGS
 * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)
 * SVG no load or failure in Opera XHR
 * Reported issues with IE7/8
 */

(function () {
	&#34;use strict&#34;;

// constructor
	/**
	 * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
	 * a single file, or queue of files.
	 *
	 * &lt;b&gt;Creating a Queue&lt;/b&gt;&lt;br /&gt;
	 * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR
	 * argument to false.
	 *
	 *      var queue = new createjs.LoadQueue(true);
	 *
	 * &lt;b&gt;Listening for Events&lt;/b&gt;&lt;br /&gt;
	 * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink &#34;EventDispatcher&#34;}}{{/crossLink}}
	 * lets you add as many listeners as you want for events. You can subscribe to the following events:&lt;ul&gt;
	 *     &lt;li&gt;{{#crossLink &#34;AbstractLoader/complete:event&#34;}}{{/crossLink}}: fired when a queue completes loading all
	 *     files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;AbstractLoader/error:event&#34;}}{{/crossLink}}: fired when the queue encounters an error with
	 *     any file.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;AbstractLoader/progress:event&#34;}}{{/crossLink}}: Progress for the entire queue has
	 *     changed.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;LoadQueue/fileload:event&#34;}}{{/crossLink}}: A single file has completed loading.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;LoadQueue/fileprogress:event&#34;}}{{/crossLink}}: Progress for a single file has changes. Note
	 *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 *      queue.on(&#34;fileload&#34;, handleFileLoad, this);
	 *      queue.on(&#34;complete&#34;, handleComplete, this);
	 *
	 * &lt;b&gt;Adding files and manifests&lt;/b&gt;&lt;br /&gt;
	 * Add files you want to load using {{#crossLink &#34;LoadQueue/loadFile&#34;}}{{/crossLink}} or add multiple files at a
	 * time using a list or a manifest definition using {{#crossLink &#34;LoadQueue/loadManifest&#34;}}{{/crossLink}}. Files are
	 * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
	 * like.
	 *
	 *      queue.loadFile(&#34;filePath/file.jpg&#34;);
	 *      queue.loadFile({id:&#34;image&#34;, src:&#34;filePath/file.jpg&#34;});
	 *      queue.loadManifest([&#34;filePath/file.jpg&#34;, {id:&#34;image&#34;, src:&#34;filePath/file.jpg&#34;}]);
	 *
	 *      // Use an external manifest
	 *      queue.loadManifest(&#34;path/to/manifest.json&#34;);
	 *      queue.loadManifest({src:&#34;manifest.json&#34;, type:&#34;manifest&#34;});
	 *
	 * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not
	 * stop if it has already been started. Call the {{#crossLink &#34;AbstractLoader/load&#34;}}{{/crossLink}} method to begin
	 * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
	 * `loadNow` argument of `true`.
	 *
	 *      queue.load();
	 *
	 * &lt;b&gt;File Types&lt;/b&gt;&lt;br /&gt;
	 * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
	 * should handle the majority of standard file and url formats, and works with common file extensions. If you have
	 * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
	 * &lt;code&gt;type&lt;/code&gt; property with any manifest item.
	 *
	 *      queue.loadFile({src:&#34;path/to/myFile.mp3x&#34;, type:createjs.Types.SOUND});
	 *
	 *      // Note that PreloadJS will not read a file extension from the query string
	 *      queue.loadFile({src:&#34;http://server.com/proxy?file=image.jpg&#34;, type:createjs.Types.IMAGE});
	 *
	 * Supported types are defined on the {{#crossLink &#34;AbstractLoader&#34;}}{{/crossLink}} class, and include:
	 * &lt;ul&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/BINARY:property&#34;}}{{/crossLink}}: Raw binary data via XHR&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/CSS:property&#34;}}{{/crossLink}}: CSS files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/IMAGE:property&#34;}}{{/crossLink}}: Common image formats&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/JAVASCRIPT:property&#34;}}{{/crossLink}}: JavaScript files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/JSON:property&#34;}}{{/crossLink}}: JSON data&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/JSONP:property&#34;}}{{/crossLink}}: JSON files cross-domain&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/MANIFEST:property&#34;}}{{/crossLink}}: A list of files to load in JSON format, see
	 *     {{#crossLink &#34;AbstractLoader/loadManifest&#34;}}{{/crossLink}}&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/SOUND:property&#34;}}{{/crossLink}}: Audio file formats&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/SPRITESHEET:property&#34;}}{{/crossLink}}: JSON SpriteSheet definitions. This
	 *     will also load sub-images, and provide a {{#crossLink &#34;SpriteSheet&#34;}}{{/crossLink}} instance.&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/SVG:property&#34;}}{{/crossLink}}: SVG files&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/TEXT:property&#34;}}{{/crossLink}}: Text files - XHR only&lt;/li&gt;
     *     &lt;li&gt;{{#crossLink &#34;Types/VIDEO:property&#34;}}{{/crossLink}}: Video objects&lt;/li&gt;
	 *     &lt;li&gt;{{#crossLink &#34;Types/XML:property&#34;}}{{/crossLink}}: XML data&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * &lt;em&gt;Note: Loader types used to be defined on LoadQueue, but have been moved to the Types class&lt;/em&gt;
	 *
	 * &lt;b&gt;Handling Results&lt;/b&gt;&lt;br /&gt;
	 * When a file is finished downloading, a {{#crossLink &#34;LoadQueue/fileload:event&#34;}}{{/crossLink}} event is
	 * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
	 * formatted object that can be used immediately, including:
	 * &lt;ul&gt;
	 *     &lt;li&gt;Binary: The binary loaded result&lt;/li&gt;
	 *     &lt;li&gt;CSS: A &amp;lt;link /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;Image: An &amp;lt;img /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;JavaScript: A &amp;lt;script /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;JSON/JSONP: A formatted JavaScript Object&lt;/li&gt;
	 *     &lt;li&gt;Manifest: A JavaScript object.
	 *     &lt;li&gt;Sound: An &amp;lt;audio /&amp;gt; tag&lt;/a&gt;
	 *     &lt;li&gt;SpriteSheet: A {{#crossLink &#34;SpriteSheet&#34;}}{{/crossLink}} instance, containing loaded images.
	 *     &lt;li&gt;SVG: An &amp;lt;object /&amp;gt; tag&lt;/li&gt;
	 *     &lt;li&gt;Text: Raw text&lt;/li&gt;
     *     &lt;li&gt;Video: A Video DOM node&lt;/li&gt;
	 *     &lt;li&gt;XML: An XML DOM node&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 *      function handleFileLoad(event) {
	 *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
	 *          var type = item.type;
	 *
	 *          // Add any images to the page body.
	 *          if (type == createjs.Types.IMAGE) {
	 *              document.body.appendChild(event.result);
	 *          }
	 *      }
	 *
	 * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
	 * via its &#34;id&#34; using {{#crossLink &#34;LoadQueue/getResult&#34;}}{{/crossLink}}. If no id was provided, then the
	 * &#34;src&#34; or file path can be used instead, including the `path` defined by a manifest, but &lt;strong&gt;not including&lt;/strong&gt;
	 * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.
	 *
	 *      var image = queue.getResult(&#34;image&#34;);
	 *      document.body.appendChild(image);
	 *
	 * Raw loaded content can be accessed using the &lt;code&gt;rawResult&lt;/code&gt; property of the {{#crossLink &#34;LoadQueue/fileload:event&#34;}}{{/crossLink}}
	 * event, or can be looked up using {{#crossLink &#34;LoadQueue/getResult&#34;}}{{/crossLink}}, passing `true` as the 2nd
	 * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
	 * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
	 *
	 *      var image = queue.getResult(&#34;image&#34;, true); // load the binary image data loaded with XHR.
	 *
	 * &lt;b&gt;Plugins&lt;/b&gt;&lt;br /&gt;
	 * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
	 * make sure to install the &lt;a href=&#34;http://soundjs.com&#34;&gt;SoundJS&lt;/a&gt; Sound class, which will help load HTML audio,
	 * Flash audio, and WebAudio files. This should be installed &lt;strong&gt;before&lt;/strong&gt; loading any audio files.
	 *
	 *      queue.installPlugin(createjs.Sound);
	 *
	 * &lt;h4&gt;Known Browser Issues&lt;/h4&gt;
	 * &lt;ul&gt;
	 *     &lt;li&gt;Browsers without audio support can not load audio files.&lt;/li&gt;
	 *     &lt;li&gt;Safari on Mac OS X can only play HTML audio if QuickTime is installed&lt;/li&gt;
	 *     &lt;li&gt;HTML Audio tags will only download until their &lt;code&gt;canPlayThrough&lt;/code&gt; event is fired. Browsers other
	 *     than Chrome will continue to download in the background.&lt;/li&gt;
	 *     &lt;li&gt;When loading scripts using tags, they are automatically added to the document.&lt;/li&gt;
	 *     &lt;li&gt;Scripts loaded via XHR may not be properly inspectable with browser tools.&lt;/li&gt;
	 *     &lt;li&gt;IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
	 *     XHR to work.&lt;/li&gt;
	 *     &lt;li&gt;Content loaded via tags will not show progress, and will continue to download in the background when
	 *     canceled, although no events will be dispatched.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * @class LoadQueue
	 * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
	 * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR
	 * when necessary.
	 * @param {String} [basePath=&#34;&#34;] A path that will be prepended on to the source parameter of all items in the queue
	 * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`
	 * will not receive a base path.
	 * @param {String|Boolean} [crossOrigin=&#34;&#34;] An optional flag to support images loaded from a CORS-enabled server. To
	 * use it, set this value to `true`, which will default the crossOrigin property on images to &#34;Anonymous&#34;. Any
	 * string value will be passed through, but only &#34;&#34; and &#34;Anonymous&#34; are recommended. &lt;strong&gt;Note: The crossOrigin
	 * parameter is deprecated. Use LoadItem.crossOrigin instead&lt;/strong&gt;
	 *
	 * @constructor
	 * @extends AbstractLoader
	 */
	function LoadQueue (preferXHR, basePath, crossOrigin) {
		this.AbstractLoader_constructor();

		/**
		 * An array of the plugins registered using {{#crossLink &#34;LoadQueue/installPlugin&#34;}}{{/crossLink}}.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this._plugins = [];

		/**
		 * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink &#34;LoadQueue/installPlugin&#34;}}{{/crossLink}}
		 * method for more information.
		 * @property _typeCallbacks
		 * @type {Object}
		 * @private
		 */
		this._typeCallbacks = {};

		/**
		 * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink &#34;LoadQueue/installPlugin&#34;}}{{/crossLink}}
		 * method for more information.
		 * @property _extensionCallbacks
		 * @type {null}
		 * @private
		 */
		this._extensionCallbacks = {};

		/**
		 * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and
		 * {{#crossLink &#34;LoadQueue/stopOnError:property&#34;}}{{/crossLink}} is `true`, the next queue will not be processed.
		 * @property next
		 * @type {LoadQueue}
		 * @default null
		 */
		this.next = null;

		/**
		 * Ensure loaded scripts &#34;complete&#34; in the order they are specified. Loaded scripts are added to the document head
		 * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas
		 * scripts loaded using XHR can load in any order, but will &#34;finish&#34; and be added to the document in the order
		 * specified.
		 *
		 * Any items can be set to load in order by setting the {{#crossLink &#34;maintainOrder:property&#34;}}{{/crossLink}}
		 * property on the load item, or by ensuring that only one connection can be open at a time using
		 * {{#crossLink &#34;LoadQueue/setMaxConnections&#34;}}{{/crossLink}}. Note that when the `maintainScriptOrder` property
		 * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the
		 * `maintainScriptOrder` to `false` during a load will not change items already in a queue.
		 *
		 * &lt;h4&gt;Example&lt;/h4&gt;
		 *
		 *      var queue = new createjs.LoadQueue();
		 *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once
		 *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order
		 *      queue.loadManifest([
		 *          &#34;script1.js&#34;,
		 *          &#34;script2.js&#34;,
		 *          &#34;image.png&#34;, // Load any time
		 *          {src: &#34;image2.png&#34;, maintainOrder: true} // Will wait for script2.js
		 *          &#34;image3.png&#34;,
		 *          &#34;script3.js&#34; // Will wait for image2.png before loading (or completing when loading with XHR)
		 *      ]);
		 *
		 * @property maintainScriptOrder
		 * @type {Boolean}
		 * @default true
		 */
		this.maintainScriptOrder = true;

		/**
		 * Determines if the LoadQueue will stop processing the current queue when an error is encountered.
		 * @property stopOnError
		 * @type {Boolean}
		 * @default false
		 */
		this.stopOnError = false;

		/**
		 * The number of maximum open connections that a loadQueue tries to maintain. Please see
		 * {{#crossLink &#34;LoadQueue/setMaxConnections&#34;}}{{/crossLink}} for more information.
		 * @property _maxConnections
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._maxConnections = 1;

		/**
		 * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the
		 * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can
		 * handle the content, it will be selected. The default loader, ({{#crossLink &#34;TextLoader&#34;}}{{/crossLink}} is
		 * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the
		 * {{#crossLink &#34;LoadItem/type&#34;}}{{/crossLink}}, which is automatically determined using the file extension of
		 * the {{#crossLink &#34;LoadItem/src:property&#34;}}{{/crossLink}}.
		 *
		 * Loaders can be removed from PreloadJS by simply not including them.
		 *
		 * Custom loaders installed using {{#crossLink &#34;registerLoader&#34;}}{{/crossLink}} will be prepended to this list
		 * so that they are checked first.
		 * @property _availableLoaders
		 * @type {Array}
		 * @private
		 * @since 0.6.0
		 */
		this._availableLoaders = [
            createjs.FontLoader,
			createjs.ImageLoader,
			createjs.JavaScriptLoader,
			createjs.CSSLoader,
			createjs.JSONLoader,
			createjs.JSONPLoader,
			createjs.SoundLoader,
			createjs.ManifestLoader,
			createjs.SpriteSheetLoader,
			createjs.XMLLoader,
			createjs.SVGLoader,
			createjs.BinaryLoader,
			createjs.VideoLoader,
			createjs.TextLoader
		];

		/**
		 * The number of built in loaders, so they can&#39;t be removed by {{#crossLink &#34;unregisterLoader&#34;}}{{/crossLink}.
				 * @property _defaultLoaderLength
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._defaultLoaderLength = this._availableLoaders.length;

		this.init(preferXHR, basePath, crossOrigin);
	}

	var p = createjs.extend(LoadQueue, createjs.AbstractLoader);
	var s = LoadQueue;

	// Remove these @deprecated properties after 1.0
	try {
		Object.defineProperties(s, {
			POST: { get: createjs.deprecate(function() { return createjs.Methods.POST; }, &#34;AbstractLoader.POST&#34;) },
			GET: { get: createjs.deprecate(function() { return createjs.Methods.GET; }, &#34;AbstractLoader.GET&#34;) },

			BINARY: { get: createjs.deprecate(function() { return createjs.Types.BINARY; }, &#34;AbstractLoader.BINARY&#34;) },
			CSS: { get: createjs.deprecate(function() { return createjs.Types.CSS; }, &#34;AbstractLoader.CSS&#34;) },
			FONT: { get: createjs.deprecate(function() { return createjs.Types.FONT; }, &#34;AbstractLoader.FONT&#34;) },
			FONTCSS: { get: createjs.deprecate(function() { return createjs.Types.FONTCSS; }, &#34;AbstractLoader.FONTCSS&#34;) },
			IMAGE: { get: createjs.deprecate(function() { return createjs.Types.IMAGE; }, &#34;AbstractLoader.IMAGE&#34;) },
			JAVASCRIPT: { get: createjs.deprecate(function() { return createjs.Types.JAVASCRIPT; }, &#34;AbstractLoader.JAVASCRIPT&#34;) },
			JSON: { get: createjs.deprecate(function() { return createjs.Types.JSON; }, &#34;AbstractLoader.JSON&#34;) },
			JSONP: { get: createjs.deprecate(function() { return createjs.Types.JSONP; }, &#34;AbstractLoader.JSONP&#34;) },
			MANIFEST: { get: createjs.deprecate(function() { return createjs.Types.MANIFEST; }, &#34;AbstractLoader.MANIFEST&#34;) },
			SOUND: { get: createjs.deprecate(function() { return createjs.Types.SOUND; }, &#34;AbstractLoader.SOUND&#34;) },
			VIDEO: { get: createjs.deprecate(function() { return createjs.Types.VIDEO; }, &#34;AbstractLoader.VIDEO&#34;) },
			SPRITESHEET: { get: createjs.deprecate(function() { return createjs.Types.SPRITESHEET; }, &#34;AbstractLoader.SPRITESHEET&#34;) },
			SVG: { get: createjs.deprecate(function() { return createjs.Types.SVG; }, &#34;AbstractLoader.SVG&#34;) },
			TEXT: { get: createjs.deprecate(function() { return createjs.Types.TEXT; }, &#34;AbstractLoader.TEXT&#34;) },
			XML: { get: createjs.deprecate(function() { return createjs.Types.XML; }, &#34;AbstractLoader.XML&#34;) }
		});
	} catch (e) {}

	/**
	 * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.
	 * @method init
	 * @param preferXHR
	 * @param basePath
	 * @param crossOrigin
	 * @private
	 */
	p.init = function (preferXHR, basePath, crossOrigin) {

		// public properties

		/**
		 * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR
		 * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,
		 * and plain text can not be loaded with tags, so it will default the the correct type instead of using the
		 * user-defined type.
		 * @type {Boolean}
		 * @default true
		 * @since 0.6.0
		 */
		this.preferXHR = true; //TODO: Get/Set
		this._preferXHR = true;
		this.setPreferXHR(preferXHR);

		// protected properties
		/**
		 * Whether the queue is currently paused or not.
		 * @property _paused
		 * @type {boolean}
		 * @private
		 */
		this._paused = false;

		/**
		 * A path that will be prepended on to the item&#39;s {{#crossLink &#34;LoadItem/src:property&#34;}}{{/crossLink}}. The
		 * `_basePath` property will only be used if an item&#39;s source is relative, and does not include a protocol such
		 * as `http://`, or a relative path such as `../`.
		 * @property _basePath
		 * @type {String}
		 * @private
		 * @since 0.3.1
		 */
		this._basePath = basePath;

		/**
		 * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded
		 * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by
		 * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,
		 * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are &#34;&#34;
		 * and &#34;Anonymous&#34;.
		 * @property _crossOrigin
		 * @type {String}
		 * @default &#34;&#34;
		 * @private
		 * @since 0.4.1
		 */
		this._crossOrigin = crossOrigin;

		/**
		 * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first
		 * file is requested.
		 * @property _loadStartWasDispatched
		 * @type {Boolean}
		 * @default false
		 * @private
		 */
		this._loadStartWasDispatched = false;

		/**
		 * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when
		 * using a script tag to do preloading.
		 * @property _currentlyLoadingScript
		 * @type {Boolean}
		 * @private
		 */
		this._currentlyLoadingScript = null;

		/**
		 * An array containing the currently downloading files.
		 * @property _currentLoads
		 * @type {Array}
		 * @private
		 */
		this._currentLoads = [];

		/**
		 * An array containing the queued items that have not yet started downloading.
		 * @property _loadQueue
		 * @type {Array}
		 * @private
		 */
		this._loadQueue = [];

		/**
		 * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.
		 * @property _loadQueueBackup
		 * @type {Array}
		 * @private
		 */
		this._loadQueueBackup = [];

		/**
		 * An object hash of items that have finished downloading, indexed by the {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}}
		 * id.
		 * @property _loadItemsById
		 * @type {Object}
		 * @private
		 */
		this._loadItemsById = {};

		/**
		 * An object hash of items that have finished downloading, indexed by {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}}
		 * source.
		 * @property _loadItemsBySrc
		 * @type {Object}
		 * @private
		 */
		this._loadItemsBySrc = {};

		/**
		 * An object hash of loaded items, indexed by the ID of the {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}}.
		 * @property _loadedResults
		 * @type {Object}
		 * @private
		 */
		this._loadedResults = {};

		/**
		 * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}}.
		 * @property _loadedRawResults
		 * @type {Object}
		 * @private
		 */
		this._loadedRawResults = {};

		/**
		 * The number of items that have been requested. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded. This does not include items inside of loaders such as the
		 * {{#crossLink &#34;ManifestLoader&#34;}}{{/crossLink}}.
		 * @property _numItems
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItems = 0;

		/**
		 * The number of items that have completed loaded. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded.
		 * @property _numItemsLoaded
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItemsLoaded = 0;

		/**
		 * A list of scripts in the order they were requested. This helps ensure that scripts are &#34;completed&#34; in the right
		 * order.
		 * @property _scriptOrder
		 * @type {Array}
		 * @private
		 */
		this._scriptOrder = [];

		/**
		 * A list of scripts that have been loaded. Items are added to this list as &lt;code&gt;null&lt;/code&gt; when they are
		 * requested, contain the loaded item if it has completed, but not been dispatched to the user, and &lt;code&gt;true&lt;/true&gt;
		 * once they are complete and have been dispatched.
		 * @property _loadedScripts
		 * @type {Array}
		 * @private
		 */
		this._loadedScripts = [];

		/**
		 * The last progress amount. This is used to suppress duplicate progress events.
		 * @property _lastProgress
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._lastProgress = NaN;

	};

// static properties

// events
	/**
	 * This event is fired when an individual file has loaded, and been processed.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink &#34;LoadQueue/loadFile&#34;}}{{/crossLink}}
	 * or {{#crossLink &#34;LoadQueue/loadManifest&#34;}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.3.0
	 */

	/**
	 * This {{#crossLink &#34;ProgressEvent&#34;}}{{/crossLink}} that is fired when an an individual file&#39;s progress changes.
	 * @event fileprogress
	 * @since 0.3.0
	 */

	/**
	 * This event is fired when an individual file starts to load.
	 * @event filestart
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink &#34;LoadQueue/loadFile&#34;}}{{/crossLink}}
	 * or {{#crossLink &#34;LoadQueue/loadManifest&#34;}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a property.
	 */

	/**
	 * Although it extends {{#crossLink &#34;AbstractLoader&#34;}}{{/crossLink}}, the `initialize` event is never fired from
	 * a LoadQueue instance.
	 * @event initialize
	 * @private
	 */

// public methods
	/**
	 * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.
	 * It is recommended that loaders extend {{#crossLink &#34;AbstractLoader&#34;}}{{/crossLink}}. Loaders can only be added
	 * once, and will be prepended to the list of available loaders.
	 * @method registerLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to add.
	 * @since 0.6.0
	 */
	p.registerLoader = function (loader) {
		if (!loader || !loader.canLoadItem) {
			throw new Error(&#34;loader is of an incorrect type.&#34;);
		} else if (this._availableLoaders.indexOf(loader) != -1) {
			throw new Error(&#34;loader already exists.&#34;); //LM: Maybe just silently fail here
		}

		this._availableLoaders.unshift(loader);
	};

	/**
	 * Remove a custom loader added using {{#crossLink &#34;registerLoader&#34;}}{{/crossLink}}. Only custom loaders can be
	 * unregistered, the default loaders will always be available.
	 * @method unregisterLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to remove
	 */
	p.unregisterLoader = function (loader) {
		var idx = this._availableLoaders.indexOf(loader);
		if (idx != -1 &amp;&amp; idx &lt; this._defaultLoaderLength - 1) {
			this._availableLoaders.splice(idx, 1);
		}
	};

	/**
	 * Change the {{#crossLink &#34;preferXHR:property&#34;}}{{/crossLink}} value. Note that if this is set to `true`, it may
	 * fail, or be ignored depending on the browser&#39;s capabilities and the load type.
	 * @method setPreferXHR
	 * @param {Boolean} value
	 * @returns {Boolean} The value of {{#crossLink &#34;preferXHR&#34;}}{{/crossLink}} that was successfully set.
	 * @since 0.6.0
	 */
	p.setPreferXHR = function (value) {
		// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.
		//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.
		this.preferXHR = (value != false &amp;&amp; window.XMLHttpRequest != null);
		return this.preferXHR;
	};

	/**
	 * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
	 * content, and allows the queue to be used again.
	 * @method removeAll
	 * @since 0.3.0
	 */
	p.removeAll = function () {
		this.remove();
	};

	/**
	 * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
	 * This also removes internal references to loaded item(s).
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      queue.loadManifest([
	 *          {src:&#34;test.png&#34;, id:&#34;png&#34;},
	 *          {src:&#34;test.jpg&#34;, id:&#34;jpg&#34;},
	 *          {src:&#34;test.mp3&#34;, id:&#34;mp3&#34;}
	 *      ]);
	 *      queue.remove(&#34;png&#34;); // Single item by ID
	 *      queue.remove(&#34;png&#34;, &#34;test.jpg&#34;); // Items as arguments. Mixed id and src.
	 *      queue.remove([&#34;test.png&#34;, &#34;jpg&#34;]); // Items in an Array. Mixed id and src.
	 *
	 * @method remove
	 * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
	 * items, or multiple items as arguments.
	 * @since 0.3.0
	 */
	p.remove = function (idsOrUrls) {
		var args = null;

		if (idsOrUrls &amp;&amp; !Array.isArray(idsOrUrls)) {
			args = [idsOrUrls];
		} else if (idsOrUrls) {
			args = idsOrUrls;
		} else if (arguments.length &gt; 0) {
			return;
		}

		var itemsWereRemoved = false;

		// Destroy everything
		if (!args) {
			this.close();
			for (var n in this._loadItemsById) {
				this._disposeItem(this._loadItemsById[n]);
			}
			this.init(this.preferXHR, this._basePath);

			// Remove specific items
		} else {
			while (args.length) {
				var item = args.pop();
				var r = this.getResult(item);

				//Remove from the main load Queue
				for (i = this._loadQueue.length - 1; i &gt;= 0; i--) {
					loadItem = this._loadQueue[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueue.splice(i, 1)[0].cancel();
						break;
					}
				}

				//Remove from the backup queue
				for (i = this._loadQueueBackup.length - 1; i &gt;= 0; i--) {
					loadItem = this._loadQueueBackup[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueueBackup.splice(i, 1)[0].cancel();
						break;
					}
				}

				if (r) {
					this._disposeItem(this.getItem(item));
				} else {
					for (var i = this._currentLoads.length - 1; i &gt;= 0; i--) {
						var loadItem = this._currentLoads[i].getItem();
						if (loadItem.id == item || loadItem.src == item) {
							this._currentLoads.splice(i, 1)[0].cancel();
							itemsWereRemoved = true;
							break;
						}
					}
				}
			}

			// If this was called during a load, try to load the next item.
			if (itemsWereRemoved) {
				this._loadNext();
			}
		}
	};

	/**
	 * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
	 * be reloaded again by calling {{#crossLink &#34;AbstractLoader/load&#34;}}{{/crossLink}}. Items are not removed from the
	 * queue. To remove items use the {{#crossLink &#34;LoadQueue/remove&#34;}}{{/crossLink}} or
	 * {{#crossLink &#34;LoadQueue/removeAll&#34;}}{{/crossLink}} method.
	 * @method reset
	 * @since 0.3.0
	 */
	p.reset = function () {
		this.close();
		for (var n in this._loadItemsById) {
			this._disposeItem(this._loadItemsById[n]);
		}

		//Reset the queue to its start state
		var a = [];
		for (var i = 0, l = this._loadQueueBackup.length; i &lt; l; i++) {
			a.push(this._loadQueueBackup[i].getItem());
		}

		this.loadManifest(a, false);
	};

	/**
	 * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
	 * Currently, only one plugin can exist per type/extension.
	 *
	 * When a plugin is installed, a &lt;code&gt;getPreloadHandlers()&lt;/code&gt; method will be called on it. For more information
	 * on this method, check out the {{#crossLink &#34;SamplePlugin/getPreloadHandlers&#34;}}{{/crossLink}} method in the
	 * {{#crossLink &#34;SamplePlugin&#34;}}{{/crossLink}} class.
	 *
	 * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned
	 * from the {{#crossLink &#34;SamplePlugin/getPreloadHandlers&#34;}}{{/crossLink}} method, it will be invoked first, and its
	 * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when
	 * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these
	 * methods, check out the {{#crossLink &#34;SamplePlugin/preloadHandler&#34;}}{{/crossLink}} and {{#crossLink &#34;SamplePlugin/fileLoadHandler&#34;}}{{/crossLink}}
	 * methods on the {{#crossLink &#34;SamplePlugin&#34;}}{{/crossLink}}.
	 *
	 * @method installPlugin
	 * @param {Function} plugin The plugin class to install.
	 */
	p.installPlugin = function (plugin) {
		if (plugin == null) {
			return;
		}

		if (plugin.getPreloadHandlers != null) {
			this._plugins.push(plugin);
			var map = plugin.getPreloadHandlers();
			map.scope = plugin;

			if (map.types != null) {
				for (var i = 0, l = map.types.length; i &lt; l; i++) {
					this._typeCallbacks[map.types[i]] = map;
				}
			}

			if (map.extensions != null) {
				for (i = 0, l = map.extensions.length; i &lt; l; i++) {
					this._extensionCallbacks[map.extensions[i]] = map;
				}
			}
		}
	};

	/**
	 * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
	 * number of open connections, so any additional connections may remain in a pending state until the browser
	 * opens the connection. When loading scripts using tags, and when {{#crossLink &#34;LoadQueue/maintainScriptOrder:property&#34;}}{{/crossLink}}
	 * is `true`, only one script is loaded at a time due to browser limitations.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.setMaxConnections(10); // Allow 10 concurrent loads
	 *
	 * @method setMaxConnections
	 * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
	 * is open at any time.
	 */
	p.setMaxConnections = function (value) {
		this._maxConnections = value;
		if (!this._paused &amp;&amp; this._loadQueue.length &gt; 0) {
			this._loadNext();
		}
	};

	/**
	 * Load a single file. To add multiple files at once, use the {{#crossLink &#34;LoadQueue/loadManifest&#34;}}{{/crossLink}}
	 * method.
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink &#34;AbstractLoader/close&#34;}}{{/crossLink}} method.
	 * @method loadFile
	 * @param {LoadItem|Object|String} file The file object or path to load. A file can be either
	 * &lt;ul&gt;
	 *     &lt;li&gt;A {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}} instance&lt;/li&gt;
	 *     &lt;li&gt;An object containing properties defined by {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}}&lt;/li&gt;
	 *     &lt;li&gt;OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}}
	 *     in the background.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink &#34;LoadQueue/setPaused&#34;}}{{/crossLink}}, and the value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink &#34;Types/MANIFEST:property&#34;}}{{/crossLink}},
	 * its files will &lt;strong&gt;NOT&lt;/strong&gt; use the basePath parameter. &lt;strong&gt;The basePath parameter is deprecated.&lt;/strong&gt;
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadFile = function (file, loadNow, basePath) {
		if (file == null) {
			var event = new createjs.ErrorEvent(&#34;PRELOAD_NO_FILE&#34;);
			this._sendError(event);
			return;
		}
		this._addItem(file, null, basePath);

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * Load an array of files. To load a single file, use the {{#crossLink &#34;LoadQueue/loadFile&#34;}}{{/crossLink}} method.
	 * The files in the manifest are requested in the same order, but may complete in a different order if the max
	 * connections are set above 1 using {{#crossLink &#34;LoadQueue/setMaxConnections&#34;}}{{/crossLink}}. Scripts will load
	 * in the right order as long as {{#crossLink &#34;LoadQueue/maintainScriptOrder&#34;}}{{/crossLink}} is true (which is
	 * default).
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink &#34;AbstractLoader/close&#34;}}{{/crossLink}} method.
	 * @method loadManifest
	 * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
	 * manifests:
	 * &lt;ol&gt;
	 *     &lt;li&gt;A string path, which points to a manifest file, which is a JSON file that contains a &#34;manifest&#34; property,
	 *     which defines the list of files to load, and can optionally contain a &#34;path&#34; property, which will be
	 *     prepended to each file in the list.&lt;/li&gt;
	 *     &lt;li&gt;An object which defines a &#34;src&#34;, which is a JSON or JSONP file. A &#34;callback&#34; can be defined for JSONP
	 *     file. The JSON/JSONP file should contain a &#34;manifest&#34; property, which defines the list of files to load,
	 *     and can optionally contain a &#34;path&#34; property, which will be prepended to each file in the list.&lt;/li&gt;
	 *     &lt;li&gt;An object which contains a &#34;manifest&#34; property, which defines the list of files to load, and can
	 *     optionally contain a &#34;path&#34; property, which will be prepended to each file in the list.&lt;/li&gt;
	 *     &lt;li&gt;An Array of files to load.&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * Each &#34;file&#34; in a manifest can be either:
	 * &lt;ul&gt;
	 *     &lt;li&gt;A {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}} instance&lt;/li&gt;
	 *     &lt;li&gt;An object containing properties defined by {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}}&lt;/li&gt;
	 *     &lt;li&gt;OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}}
	 *     in the background.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink &#34;LoadQueue/setPaused&#34;}}{{/crossLink}} and this value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink &#34;LoadQueue/MANIFEST:property&#34;}}{{/crossLink}},
	 * its files will &lt;strong&gt;NOT&lt;/strong&gt; use the basePath parameter. &lt;strong&gt;The basePath parameter is deprecated.&lt;/strong&gt;
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadManifest = function (manifest, loadNow, basePath) {
		var fileList = null;
		var path = null;

		// Array-based list of items
		if (Array.isArray(manifest)) {
			if (manifest.length == 0) {
				var event = new createjs.ErrorEvent(&#34;PRELOAD_MANIFEST_EMPTY&#34;);
				this._sendError(event);
				return;
			}
			fileList = manifest;

			// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.
		} else if (typeof(manifest) === &#34;string&#34;) {
			fileList = [
				{
					src: manifest,
					type: s.MANIFEST
				}
			];

		} else if (typeof(manifest) == &#34;object&#34;) {

			// An object that defines a manifest path
			if (manifest.src !== undefined) {
				if (manifest.type == null) {
					manifest.type = s.MANIFEST;
				} else if (manifest.type != s.MANIFEST) {
					var event = new createjs.ErrorEvent(&#34;PRELOAD_MANIFEST_TYPE&#34;);
					this._sendError(event);
				}
				fileList = [manifest];

				// An object that defines a manifest
			} else if (manifest.manifest !== undefined) {
				fileList = manifest.manifest;
				path = manifest.path;
			}

			// Unsupported. This will throw an error.
		} else {
			var event = new createjs.ErrorEvent(&#34;PRELOAD_MANIFEST_NULL&#34;);
			this._sendError(event);
			return;
		}

		for (var i = 0, l = fileList.length; i &lt; l; i++) {
			this._addItem(fileList[i], path, basePath);
		}

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}

	};

	/**
	 * Start a LoadQueue that was created, but not automatically started.
	 * @method load
	 */
	p.load = function () {
		this.setPaused(false);
	};

	/**
	 * Look up a {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}} using either the &#34;id&#34; or &#34;src&#34; that was specified when loading it. Note that if no &#34;id&#34; was
	 * supplied with the load item, the ID will be the &#34;src&#34;, including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getItem
	 * @param {String} value The &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; of the load item.
	 * @return {Object} The load item that was initially requested using {{#crossLink &#34;LoadQueue/loadFile&#34;}}{{/crossLink}}
	 * or {{#crossLink &#34;LoadQueue/loadManifest&#34;}}{{/crossLink}}. This object is also returned via the {{#crossLink &#34;LoadQueue/fileload:event&#34;}}{{/crossLink}}
	 * event as the `item` parameter.
	 */
	p.getItem = function (value) {
		return this._loadItemsById[value] || this._loadItemsBySrc[value];
	};

	/**
	 * Look up a loaded result using either the &#34;id&#34; or &#34;src&#34; that was specified when loading it. Note that if no &#34;id&#34;
	 * was supplied with the load item, the ID will be the &#34;src&#34;, including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getResult
	 * @param {String} value The &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; of the load item.
	 * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * &lt;ul&gt;
	 *      &lt;li&gt;An image tag (&amp;lt;image /&amp;gt;) for images&lt;/li&gt;
	 *      &lt;li&gt;A script tag for JavaScript (&amp;lt;script /&amp;gt;). Note that scripts are automatically added to the HTML
	 *      DOM.&lt;/li&gt;
	 *      &lt;li&gt;A style tag for CSS (&amp;lt;style /&amp;gt; or &amp;lt;link &amp;gt;)&lt;/li&gt;
	 *      &lt;li&gt;Raw text for TEXT&lt;/li&gt;
	 *      &lt;li&gt;A formatted JavaScript object defined by JSON&lt;/li&gt;
	 *      &lt;li&gt;An XML document&lt;/li&gt;
	 *      &lt;li&gt;A binary arraybuffer loaded by XHR&lt;/li&gt;
	 *      &lt;li&gt;An audio tag (&amp;lt;audio &amp;gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
	 *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
	 *      which can not be used to play audio back.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * This object is also returned via the {{#crossLink &#34;LoadQueue/fileload:event&#34;}}{{/crossLink}} event as the &#39;item`
	 * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (value, rawResult) {
		var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
		if (item == null) {
			return null;
		}
		var id = item.id;
		if (rawResult &amp;&amp; this._loadedRawResults[id]) {
			return this._loadedRawResults[id];
		}
		return this._loadedResults[id];
	};

	/**
	 * Generate an list of items loaded by this queue.
	 * @method getItems
	 * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress
	 * and failed load items will also be included.
	 * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}},
	 * result, and rawResult.
	 * @since 0.6.0
	 */
	p.getItems = function (loaded) {
		var arr = [];
		for (var n in this._loadItemsById) {
			var item = this._loadItemsById[n];
			var result = this.getResult(n);
			if (loaded === true &amp;&amp; result == null) {
				continue;
			}
			arr.push({
				item: item,
				result: result,
				rawResult: this.getResult(n, true)
			});
		}
		return arr;
	};

	/**
	 * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
	 * be processed when active loads complete. LoadQueues are not paused by default.
	 *
	 * Note that if new items are added to the queue using {{#crossLink &#34;LoadQueue/loadFile&#34;}}{{/crossLink}} or
	 * {{#crossLink &#34;LoadQueue/loadManifest&#34;}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`
	 * argument is `false`.
	 * @method setPaused
	 * @param {Boolean} value Whether the queue should be paused or not.
	 */
	p.setPaused = function (value) {
		this._paused = value;
		if (!this._paused) {
			this._loadNext();
		}
	};

	/**
	 * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from
	 * starting to download. Note that currently any active loads will remain open, and events may be processed.
	 *
	 * To stop and restart a queue, use the {{#crossLink &#34;LoadQueue/setPaused&#34;}}{{/crossLink}} method instead.
	 * @method close
	 */
	p.close = function () {
		while (this._currentLoads.length) {
			this._currentLoads.pop().cancel();
		}
		this._scriptOrder.length = 0;
		this._loadedScripts.length = 0;
		this.loadStartWasDispatched = false;
		this._itemCount = 0;
		this._lastProgress = NaN;
	};

// protected methods
	/**
	 * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
	 * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
	 * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink &#34;LoadQueue.getItem&#34;}}{{/crossLink}}
	 * method.
	 * @method _addItem
	 * @param {String|Object} value The item to add to the queue.
	 * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is
	 * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was
	 * provided a {{#crossLink &#34;_basePath&#34;}}{{/crossLink}}, then it will optionally be prepended after.
	 * @param {String} [basePath] &lt;strong&gt;Deprecated&lt;/strong&gt;An optional basePath passed into a {{#crossLink &#34;LoadQueue/loadManifest&#34;}}{{/crossLink}}
	 * or {{#crossLink &#34;LoadQueue/loadFile&#34;}}{{/crossLink}} call. This parameter will be removed in a future tagged
	 * version.
	 * @private
	 */
	p._addItem = function (value, path, basePath) {
		var item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.
		if (item == null) {
			return;
		} // Sometimes plugins or types should be skipped.
		var loader = this._createLoader(item);
		if (loader != null) {
			if (&#34;plugins&#34; in loader) {
				loader.plugins = this._plugins;
			}
			item._loader = loader;
			this._loadQueue.push(loader);
			this._loadQueueBackup.push(loader);

			this._numItems++;
			this._updateProgress();

			// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.
			if ((this.maintainScriptOrder
					&amp;&amp; item.type == createjs.Types.JAVASCRIPT
						//&amp;&amp; loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way
					)
					|| item.maintainOrder === true) {
				this._scriptOrder.push(item);
				this._loadedScripts.push(null);
			}
		}
	};

	/**
	 * Create a refined {{#crossLink &#34;LoadItem&#34;}}{{/crossLink}}, which contains all the required properties. The type of
	 * item is determined by browser support, requirements based on the file type, and developer settings. For example,
	 * XHR is only used for file types that support it in new browsers.
	 *
	 * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
	 * alter the load item.
	 * @method _createLoadItem
	 * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
	 * @param {String} [path] A path to prepend to the item&#39;s source. Sources beginning with http:// or similar will
	 * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink &#34;LoadQueue/_basePath:property&#34;}}{{/crossLink}}
	 * when it is added.
	 * @param {String} [basePath] &lt;strong&gt;Deprectated&lt;/strong&gt; A base path to prepend to the items source in addition to
	 * the path argument.
	 * @return {Object} The loader instance that will be used.
	 * @private
	 */
	p._createLoadItem = function (value, path, basePath) {
		var item = createjs.LoadItem.create(value);
		if (item == null) {
			return null;
		}

		var bp = &#34;&#34;; // Store the generated basePath
		var useBasePath = basePath || this._basePath;

		if (item.src instanceof Object) {
			if (!item.type) {
				return null;
			} // the the src is an object, type is required to pass off to plugin
			if (path) {
				bp = path;
				var pathMatch = createjs.URLUtils.parseURI(path);
				// Also append basePath
				if (useBasePath != null &amp;&amp; !pathMatch.absolute &amp;&amp; !pathMatch.relative) {
					bp = useBasePath + bp;
				}
			} else if (useBasePath != null) {
				bp = useBasePath;
			}
		} else {
			// Determine Extension, etc.
			var match = createjs.URLUtils.parseURI(item.src);
			if (match.extension) {
				item.ext = match.extension;
			}
			if (item.type == null) {
				item.type = createjs.RequestUtils.getTypeByExtension(item.ext);
			}

			// Inject path &amp; basePath
			var autoId = item.src;
			if (!match.absolute &amp;&amp; !match.relative) {
				if (path) {
					bp = path;
					var pathMatch = createjs.URLUtils.parseURI(path);
					autoId = path + autoId;
					// Also append basePath
					if (useBasePath != null &amp;&amp; !pathMatch.absolute &amp;&amp; !pathMatch.relative) {
						bp = useBasePath + bp;
					}
				} else if (useBasePath != null) {
					bp = useBasePath;
				}
			}
			item.src = bp + item.src;
		}
		item.path = bp;

		// If there&#39;s no id, set one now.
		if (item.id === undefined || item.id === null || item.id === &#34;&#34;) {
			item.id = autoId;
		}

		// Give plugins a chance to modify the loadItem:
		var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
		if (customHandler) {
			// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)
			var result = customHandler.callback.call(customHandler.scope, item, this);

			// The plugin will handle the load, or has canceled it. Ignore it.
			if (result === false) {
				return null;

				// Load as normal:
			} else if (result === true) {
				// Do Nothing

				// Result is a loader class:
			} else if (result != null) {
				item._loader = result;
			}

			// Update the extension in case the type changed:
			match = createjs.URLUtils.parseURI(item.src);
			if (match.extension != null) {
				item.ext = match.extension;
			}
		}

		// Store the item for lookup. This also helps clean-up later.
		this._loadItemsById[item.id] = item;
		this._loadItemsBySrc[item.src] = item;

		if (item.crossOrigin == null) {
			item.crossOrigin = this._crossOrigin;
		}

		return item;
	};

	/**
	 * Create a loader for a load item.
	 * @method _createLoader
	 * @param {Object} item A formatted load item that can be used to generate a loader.
	 * @return {AbstractLoader} A loader that can be used to load content.
	 * @private
	 */
	p._createLoader = function (item) {
		if (item._loader != null) { // A plugin already specified a loader
			return item._loader;
		}

		// Initially, try and use the provided/supported XHR mode:
		var preferXHR = this.preferXHR;

		for (var i = 0; i &lt; this._availableLoaders.length; i++) {
			var loader = this._availableLoaders[i];
			if (loader &amp;&amp; loader.canLoadItem(item)) {
				return new loader(item, preferXHR);
			}
		}

		// TODO: Log error (requires createjs.log)
		return null;
	};

	/**
	 * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
	 * is processed. The queue will &#34;fill up&#34; any empty slots, up to the max connection specified using
	 * {{#crossLink &#34;LoadQueue.setMaxConnections&#34;}}{{/crossLink}} method. The only exception is scripts that are loaded
	 * using tags, which have to be loaded one at a time to maintain load order.
	 * @method _loadNext
	 * @private
	 */
	p._loadNext = function () {
		if (this._paused) {
			return;
		}

		// Only dispatch loadstart event when the first file is loaded.
		if (!this._loadStartWasDispatched) {
			this._sendLoadStart();
			this._loadStartWasDispatched = true;
		}

		// The queue has completed.
		if (this._numItems == this._numItemsLoaded) {
			this.loaded = true;
			this._sendComplete();

			// Load the next queue, if it has been defined.
			if (this.next &amp;&amp; this.next.load) {
				this.next.load();
			}
		} else {
			this.loaded = false;
		}

		// Must iterate forwards to load in the right order.
		for (var i = 0; i &lt; this._loadQueue.length; i++) {
			if (this._currentLoads.length &gt;= this._maxConnections) {
				break;
			}
			var loader = this._loadQueue[i];

			// Determine if we should be only loading one tag-script at a time:
			// Note: maintainOrder items don&#39;t do anything here because we can hold onto their loaded value
			if (!this._canStartLoad(loader)) {
				continue;
			}
			this._loadQueue.splice(i, 1);
			i--;
			this._loadItem(loader);
		}
	};

	/**
	 * Begin loading an item. Event listeners are not added to the loaders until the load starts.
	 * @method _loadItem
	 * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
	 * @private
	 */
	p._loadItem = function (loader) {
		loader.on(&#34;fileload&#34;, this._handleFileLoad, this);
		loader.on(&#34;progress&#34;, this._handleProgress, this);
		loader.on(&#34;complete&#34;, this._handleFileComplete, this);
		loader.on(&#34;error&#34;, this._handleError, this);
		loader.on(&#34;fileerror&#34;, this._handleFileError, this);
		this._currentLoads.push(loader);
		this._sendFileStart(loader.getItem());
		loader.load();
	};

	/**
	 * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink &#34;ManifestLoader&#34;}}{{/crossLink}}
	 * to maintain internal queues, but for this queue to dispatch the {{#crossLink &#34;fileload:event&#34;}}{{/crossLink}}
	 * events.
	 * @param {Event} event The {{#crossLink &#34;AbstractLoader/fileload:event&#34;}}{{/crossLink}} event from the loader.
	 * @private
	 * @since 0.6.0
	 */
	p._handleFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The callback that is fired when a loader encounters an error from an internal file load operation. This enables
	 * loaders like M
	 * @param event
	 * @private
	 */
	p._handleFileError = function (event) {
		var newEvent = new createjs.ErrorEvent(&#34;FILE_LOAD_ERROR&#34;, null, event.item);
		this._sendError(newEvent);
	};

	/**
	 * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink &#34;LoadQueue/stopOnError:property&#34;}}{{/crossLink}}
	 * is set to `true`.
	 * @method _handleError
	 * @param {ErrorEvent} event The error event, containing relevant error information.
	 * @private
	 */
	p._handleError = function (event) {
		var loader = event.target;
		this._numItemsLoaded++;

		this._finishOrderedItem(loader, true);
		this._updateProgress();

		var newEvent = new createjs.ErrorEvent(&#34;FILE_LOAD_ERROR&#34;, null, loader.getItem());
		// TODO: Propagate actual error message.

		this._sendError(newEvent);

		if (!this.stopOnError) {
			this._removeLoadItem(loader);
			this._cleanLoadItem(loader);
			this._loadNext();
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
	 * is available as the &#34;result&#34; property on the load item. The raw text result for a parsed item (such as JSON, XML,
	 * CSS, JavaScript, etc) is available as the &#34;rawResult&#34; property, and can also be looked up using {{#crossLink &#34;LoadQueue/getResult&#34;}}{{/crossLink}}.
	 * @method _handleFileComplete
	 * @param {Event} event The event object from the loader.
	 * @private
	 */
	p._handleFileComplete = function (event) {
		var loader = event.target;
		var item = loader.getItem();

		var result = loader.getResult();
		this._loadedResults[item.id] = result;
		var rawResult = loader.getResult(true);
		if (rawResult != null &amp;&amp; rawResult !== result) {
			this._loadedRawResults[item.id] = rawResult;
		}

		this._saveLoadedItems(loader);

		// Remove the load item
		this._removeLoadItem(loader);

		if (!this._finishOrderedItem(loader)) {
			// The item was NOT managed, so process it now
			this._processFinishedLoad(item, loader);
		}

		// Clean up the load item
		this._cleanLoadItem(loader);
	};

	/**
	 * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink &#34;ManifestLoader&#34;}}{{/crossLink}}).
	 * Any items exposed by the loader using {{#crossLink &#34;AbstractLoader/getLoadItems&#34;}}{{/crossLink}} are added to the
	 * LoadQueue&#39;s look-ups, including {{#crossLink &#34;getItem&#34;}}{{/crossLink}} and {{#crossLink &#34;getResult&#34;}}{{/crossLink}}
	 * methods.
	 * @method _saveLoadedItems
	 * @param {AbstractLoader} loader
	 * @protected
	 * @since 0.6.0
	 */
	p._saveLoadedItems = function (loader) {
		// TODO: Not sure how to handle this. Would be nice to expose the items.
		// Loaders may load sub-items. This adds them to this queue
		var list = loader.getLoadedItems();
		if (list === null) {
			return;
		}

		for (var i = 0; i &lt; list.length; i++) {
			var item = list[i].item;

			// Store item lookups
			this._loadItemsBySrc[item.src] = item;
			this._loadItemsById[item.id] = item;

			// Store loaded content
			this._loadedResults[item.id] = list[i].result;
			this._loadedRawResults[item.id] = list[i].rawResult;
		}
	};

	/**
	 * Flag an item as finished. If the item&#39;s order is being managed, then ensure that it is allowed to finish, and if
	 * so, trigger prior items to trigger as well.
	 * @method _finishOrderedItem
	 * @param {AbstractLoader} loader
	 * @param {Boolean} loadFailed
	 * @return {Boolean} If the item&#39;s order is being managed. This allows the caller to take an alternate
	 * behaviour if it is.
	 * @private
	 */
	p._finishOrderedItem = function (loader, loadFailed) {
		var item = loader.getItem();

		if ((this.maintainScriptOrder &amp;&amp; item.type == createjs.Types.JAVASCRIPT)
				|| item.maintainOrder) {

			//TODO: Evaluate removal of the _currentlyLoadingScript
			if (loader instanceof createjs.JavaScriptLoader) {
				this._currentlyLoadingScript = false;
			}

			var index = createjs.indexOf(this._scriptOrder, item);
			if (index == -1) {
				return false;
			} // This loader no longer exists
			this._loadedScripts[index] = (loadFailed === true) ? true : item;

			this._checkScriptLoadOrder();
			return true;
		}

		return false;
	};

	/**
	 * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
	 * order they were added, but with a &#34;null&#34; value. When they are completed, the value is set to the load item,
	 * and then when they are processed and dispatched, the value is set to `true`. This method simply
	 * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are
	 * dispatched.
	 * @method _checkScriptLoadOrder
	 * @private
	 */
	p._checkScriptLoadOrder = function () {
		var l = this._loadedScripts.length;

		for (var i = 0; i &lt; l; i++) {
			var item = this._loadedScripts[i];
			if (item === null) {
				break;
			} // This is still loading. Do not process further.
			if (item === true) {
				continue;
			} // This has completed, and been processed. Move on.

			var loadItem = this._loadedResults[item.id];
			if (item.type == createjs.Types.JAVASCRIPT) {
				// Append script tags to the head automatically.
				createjs.DomUtils.appendToHead(loadItem);
			}

			var loader = item._loader;
			this._processFinishedLoad(item, loader);
			this._loadedScripts[i] = true;
		}
	};

	/**
	 * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts
	 * the next item.
	 * @method _processFinishedLoad
	 * @param {LoadItem|Object} item
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._processFinishedLoad = function (item, loader) {
		this._numItemsLoaded++;

		// Since LoadQueue needs maintain order, we can&#39;t append scripts in the loader.
		// So we do it here instead. Or in _checkScriptLoadOrder();
		if (!this.maintainScriptOrder &amp;&amp; item.type == createjs.Types.JAVASCRIPT) {
			var tag = loader.getTag();
			createjs.DomUtils.appendToHead(tag);
		}

		this._updateProgress();
		this._sendFileComplete(item, loader);
		this._loadNext();
	};

	/**
	 * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to
	 * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed &lt;strong&gt;before&lt;/strong&gt;
	 * the script can even be started, since it exist in the DOM while loading.
	 * @method _canStartLoad
	 * @param {AbstractLoader} loader The loader for the item
	 * @return {Boolean} Whether the item can start a load or not.
	 * @private
	 */
	p._canStartLoad = function (loader) {
		if (!this.maintainScriptOrder || loader.preferXHR) {
			return true;
		}
		var item = loader.getItem();
		if (item.type != createjs.Types.JAVASCRIPT) {
			return true;
		}
		if (this._currentlyLoadingScript) {
			return false;
		}

		var index = this._scriptOrder.indexOf(item);
		var i = 0;
		while (i &lt; index) {
			var checkItem = this._loadedScripts[i];
			if (checkItem == null) {
				return false;
			}
			i++;
		}
		this._currentlyLoadingScript = true;
		return true;
	};

	/**
	 * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
	 * @method _removeLoadItem
	 * @param {AbstractLoader} loader A loader instance to remove.
	 * @private
	 */
	p._removeLoadItem = function (loader) {
		var l = this._currentLoads.length;
		for (var i = 0; i &lt; l; i++) {
			if (this._currentLoads[i] == loader) {
				this._currentLoads.splice(i, 1);
				break;
			}
		}
	};

	/**
	 * Remove unneeded references from a loader.
	 *
	 * @param loader
	 * @private
	 */
	p._cleanLoadItem = function(loader) {
		var item = loader.getItem();
		if (item) {
			delete item._loader;
		}
	}

	/**
	 * An item has dispatched progress. Propagate that progress, and update the LoadQueue&#39;s overall progress.
	 * @method _handleProgress
	 * @param {ProgressEvent} event The progress event from the item.
	 * @private
	 */
	p._handleProgress = function (event) {
		var loader = event.target;
		this._sendFileProgress(loader.getItem(), loader.progress);
		this._updateProgress();
	};

	/**
	 * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
	 * item dispatches progress or completes. Note that since we don&#39;t always know the actual filesize of items before
	 * they are loaded. In this case, we define a &#34;slot&#34; for each item (1 item in 10 would get 10%), and then append
	 * loaded progress on top of the already-loaded items.
	 *
	 * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:
	 * &lt;ul&gt;
	 *      &lt;li&gt;5/10 of the items in the queue (50%)&lt;/li&gt;
	 *      &lt;li&gt;plus 20% of item 6&#39;s slot (2%)&lt;/li&gt;
	 *      &lt;li&gt;equals 52%&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @method _updateProgress
	 * @private
	 */
	p._updateProgress = function () {
		var loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress
		var remaining = this._numItems - this._numItemsLoaded;
		if (remaining &gt; 0) {
			var chunk = 0;
			for (var i = 0, l = this._currentLoads.length; i &lt; l; i++) {
				chunk += this._currentLoads[i].progress;
			}
			loaded += (chunk / remaining) * (remaining / this._numItems);
		}

		if (this._lastProgress != loaded) {
			this._sendProgress(loaded);
			this._lastProgress = loaded;
		}
	};

	/**
	 * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
	 * hashes.
	 * @method _disposeItem
	 * @param {LoadItem|Object} item The item that was passed in for preloading.
	 * @private
	 */
	p._disposeItem = function (item) {
		delete this._loadedResults[item.id];
		delete this._loadedRawResults[item.id];
		delete this._loadItemsById[item.id];
		delete this._loadItemsBySrc[item.src];
	};

	/**
	 * Dispatch a &#34;fileprogress&#34; {{#crossLink &#34;Event&#34;}}{{/crossLink}}. Please see the LoadQueue {{#crossLink &#34;LoadQueue/fileprogress:event&#34;}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendFileProgress
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @param {Number} progress The amount the item has been loaded (between 0 and 1).
	 * @protected
	 */
	p._sendFileProgress = function (item, progress) {
		if (this._isCanceled() || this._paused) {
			return;
		}
		if (!this.hasEventListener(&#34;fileprogress&#34;)) {
			return;
		}

		//LM: Rework ProgressEvent to support this?
		var event = new createjs.Event(&#34;fileprogress&#34;);
		event.progress = progress;
		event.loaded = progress;
		event.total = 1;
		event.item = item;

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch a fileload {{#crossLink &#34;Event&#34;}}{{/crossLink}}. Please see the {{#crossLink &#34;LoadQueue/fileload:event&#34;}}{{/crossLink}} event for
	 * details on the event payload.
	 * @method _sendFileComplete
	 * @param {LoadItemObject} item The item that is being loaded.
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._sendFileComplete = function (item, loader) {
		if (this._isCanceled() || this._paused) {
			return;
		}

		var event = new createjs.Event(&#34;fileload&#34;);
		event.loader = loader;
		event.item = item;
		event.result = this._loadedResults[item.id];
		event.rawResult = this._loadedRawResults[item.id];

		// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.
		if (item.completeHandler) {
			item.completeHandler(event);
		}

		this.hasEventListener(&#34;fileload&#34;) &amp;&amp; this.dispatchEvent(event);
	};

	/**
	 * Dispatch a filestart {{#crossLink &#34;Event&#34;}}{{/crossLink}} immediately before a file starts to load. Please see
	 * the {{#crossLink &#34;LoadQueue/filestart:event&#34;}}{{/crossLink}} event for details on the event payload.
	 * @method _sendFileStart
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @protected
	 */
	p._sendFileStart = function (item) {
		var event = new createjs.Event(&#34;filestart&#34;);
		event.item = item;
		this.hasEventListener(&#34;filestart&#34;) &amp;&amp; this.dispatchEvent(event);
	};

	p.toString = function () {
		return &#34;[PreloadJS LoadQueue]&#34;;
	};

	createjs.LoadQueue = createjs.promote(LoadQueue, &#34;AbstractLoader&#34;);
}());

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>


</body></html>